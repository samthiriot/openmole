@import org.openmole.site.tools._
@import org.openmole.site._
@import org.openmole.site.content.Native._
@import DocumentationPages._



@h2{RTask}

R is a scripted language initially designed for statistics, but whose application range is much broader today (for example GIS, operational research, linear algebra, web applications, etc.), thanks to its large community and the variety of packages.
It may be convenient to use specific R libraries within a workflow, and therefore OpenMOLE provides a specific @code{RTask}.


@h3{Preliminary remark}

@usesSingularity("RTask")


@h3{RTask syntax}

The @code{RTask} relies on an underlying @code{ContainerTask} but is designed to be transparent and takes only R-related arguments.
The current version of R used is @b{@shared.rTask.rVersion}.
It takes the following arguments :

@ul
   @li{@code{script} String, mandatory. The R script to be executed.}
   @li{@code{install} Sequence of strings, optional (default = empty). The commands to be executed prior to any R packages installation and R script execution (see example below: some R libraries may have system dependencies, that have to be installed first).}
   @li{@code{libraries} Sequence of strings, optional (default = empty). The name of R libraries that will be used by the script and need to be installed before (note: as detailed below, installations are only done during the first execution of the R script, and then stored in a docker image in cache. To force an update, use the @i{forceUpdate} argument).}
   @li{@code{forceUpdate} Boolean, optional (default = false). Should the libraries installation be forced (to ensure an update for example). If true, the task will perform the installation (and thus the update) even if the library was already installed.}

@br

The following properties must be defined using @code{set} :

@ul
   @li{@code{input/output} similar to any other task}
   @li{mapped input: the syntax @code{inputs += prototype mapped "r-variable"} establishes a link between the workflow variable @code{prototype} (Val) and the corresponding R variable name @code{"r-variable"} (String)
   If variables have the same name, you can use the short syntax @code{inputs += prototype.mapped}}
   @li{mapped output: similar syntax as inputs to collect outputs of the model}

@br

We develop below a detailed example of how to use a RTask, from a very simple use to a more elaborate with system libraries and R libraries.



@h2{Example 1: A simple RTask}

The toy R script for this first test case is:

@br@br

@hl("""
    f = function(x){
          x+1
        }
    j = f(2)
""", "R")

@br

We save this to @i{Rscript1.R}, it will be used in the second part.

@br@br

Here we create a function @code{f} and a variable @code{j} in which we store the result of the evaluation of the function.
For this first script example, we write the R script directly in the @code{RTask}.
We will see below how to import it from a @i{file.R}, deal with libraries, and plug inputs and outputs between OpenMOLE and R.

@br@br

@openmole(s"""
    // Task
    val rTask1 = RTask($tq
        # Here you write code in R
        f = function(x){
            x+1
        }
        j = f(2)
    $tq)

    // Workflow
    rTask1
""" )


@h3{Running a script from a file}

You can now upload @i{Rscript1.R} to your OpenMOLE workspace.

@br

Here is the OpenMOLE script to use in the @code{RTask}.
In the @code{resources} field, you have to provide the precise location of the @i{file.R}, which is then imported in the R script using the R primitive @code{source()}).

@br@br

@openmole( s"""
    // Task
    val rTask2 = RTask($tq
        source("Rscript1.R")
    $tq) set (
        resources += workDirectory / "Rscript1.R"
    )

    // Workflow
    rTask2
    """)


@h3{Input and output values}

In this script we want to pass the OpenMOLE variable @code{i} to the @code{RTask}.
It is possible to do so through an @code{input} in the @code{set} of the task.
@code{i} can be a variable whose value is given by a previous task, but here we choose to set it manually to 3.

@br

Remark: here the OpenMOLE variable has the same name as the R variable @code{i}, but it is not mandatory as we will see below.

@br@br

@openmole( s"""
    // Declare variable
    val i = Val[Int]

    // Task
    val rTask3 = RTask($tq
        f = function(x){
            x+1
        }
        j = f(i)
    $tq) set (
        inputs += i.mapped,
        i := 3
    )

    // Workflow
    rTask3
""")

@br

In the script below (@code{rTask4}), we add an output variable @code{j}, and we change the name of the R variable (now @code{varRi}) which is mapped to the OpenMOLE variable @code{i}.

@br@br

@openmole( s"""
    // Declare variables
    val i = Val[Int]
    val j = Val[Int]

    // Task
    val rTask4 = RTask($tq
        f= function(x){
            x+1
        }
        j = f(varRi)
    $tq) set(
        inputs += i mapped "varRi",
        outputs += j.mapped,
        i := 3
    )

    // Workflow
    rTask4 hook display
""")

@br

Remark: if you have several outputs, you can combine @code{mapped outputs} with classic @code{outputs} that are not part of the R task (for example, the variable @i{c} in @i{rTask5} below).

@br@br

@openmole( s"""
    // Declare variables
    val i = Val[Int]
    val j = Val[Double]
    val c = Val[Double]

    // Task
    val rTask5 =
    RTask($tq
        f = function(x){
             x+1
        }
        j = f(i)
    $tq) set (
        inputs += i.mapped,
        (inputs, outputs) += c,
        outputs +=  j.mapped,
        outputs += i.mapped,
        i := 3 ,
        c:=2
    )

    // Workflow
    rTask5 hook display
""")

@br

This technique can be used when you have a chain of tasks and you want to use a hook.
Indeed, the hook only captures outputs of the last task, thus we can add a variable of interest in the output of the task even if it does not appear in this task.
Note that the last section presents an alternative.



@h2{Example 2: Working with files}

It is also possible to pass files as argument of the @code{RTask}.
However, we can't pass them with @code{rInputs} as seen before, as it will result in a type mismatch with an error message like @i{type class java.io.File is not convertible to JSON}.
We thus use @code{inputFiles}, and  we give an illustration in the following workflow (@code{rTask}).
We emphasize that @code{inputFiles} must be used here (and not @code{resources}), since it is used as a @code{Val} and can be acted upon in a workflow, whereas @code{resources} act differently since they are fixed.

@br@br

We have first a @code{ScalaTask} which writes numbers in a file.
The file is the OpenMOLE variable  @code{g} of type @i{java.io.File}.
In order to have access to this file in the @code{RTask}, we add @code{g} as an output of the @code{ScalaTask}.
The R script in the @code{RTask} reads a file named @code{fileForR} (in the R script presented here, it is supposed to have numeric values, separated by a simple space), and creates a R variable @code{temp2}, which is a vector containing the value of the file @code{fileForR}.
We then apply the function @code{f} to that vector.
The end of the workflow simply tells OpenMOLE to chain the two tasks and to display the outputs of the last task (here the OpenMOLE variable @code{resR}).

@br@br

Note that the @code{g} is an OpenMOLE variable.
If you want to see the file created in your workspace, you can use a @aa("hook", href := hook.file).
Note that you have to put @code{g} as an output of the @code{RTask} (see the section "A complete workflow", below to have a workflow example).

@br@br

@openmole( s"""
    // Declare variable
    val g = Val[File]

    // Task
    val task1 = ScalaTask($tq
        val g = newFile()
        g.content = "3 6 4"
    $tq) set (
        outputs += g
    )

    /////////////////////////////

    // Declare variable
    val resR =  Val[Array[Double]]

    // Task
    val rTask = RTask($tq
        temp1=read.table("fileForR", sep="")
        temp2=as.vector(temp1,mode = "numeric")

        f= function(x) {
            x+1
        }
        k=f(temp2)
    $tq) set(
        inputFiles += (g, "fileForR"),
        outputs += resR mapped "k"
    )

    // Workflow
    task1 -- (rTask hook display)
""")



@h2{Example 3: Use a library}

Here we give an example of how to use a library in an @code{RTask}.
We use the function @code{CHullArea} of the library @code{GeoRange} to compute the area in the convex envelop of a set of points.

@br@br

Write the names of the libraries you need in the field @code{libraries}, and adapt the @code{install} field accordingly.
The @code{install} argument is a sequence of system commands which are executed prior to the installation of the R libraries.
It can be used to install the packages which are required by the R libraries.
The @code{RTask} is based on a Debian container, therefore you can use any Debian command here including @code{apt} installation tool.

Note: if your instance of OpenMole is executed inside a docker container, if your installation commands require superuser privileges, 
then you might prepend your command with @code{fakeroot}.

@br

The @code{libraries} argument is a sequence of libraries that are installed from the CRAN repository.

@br@br

Remark: the first time you use R with @code{libraries} or @code{packages}, it takes some time to install them, but for the next uses those libraries will be stored, and the execution will be quicker.

@br@br

@openmole( s"""
    // Declare variable
    val area = Val[Double]

    // Task
    val rTask3 = RTask($tq
        library(GeoRange)
        n=40
        x = rexp(n, 5)
        y = rexp(n, 5)

        # to have the convex envelopp of the set of points we created
        liste = chull(x,y)
        hull <- cbind(x,y) [liste,]

        #require GeoRange
        area=CHullArea(hull[,1],hull[,2])
        $tq,
        install = Seq("apt update", "apt install -y libgdal-dev libproj-dev"),
        libraries = Seq("GeoRange")
    ) set(
        outputs += area.mapped
    )

    // Workflow
    rTask3 hook display
    """)


@h2{Example 4: A complete workflow}

Here is an example of an (almost complete) workflow using a @code{RTask}, it uses @code{rInputs, inputFiles, install} (you can add your R script using @code{resource})

@br@br

The first task is a @code{ScalaTask} whose aim is to create OpenMOLE variables that will be used in the @code{RTask}.
We provide them to the @code{RTask} using @code{inputFiles} and @code{inputs} keywords.

@br

Notice that the conversion from the OpenMOLE type (Scala) @code{Array[Double]} to the R type vector is made directly by the @code{inputs}.

@br

The hook stores the file @code{g} in your workspace} and displays the @code{area}.

@br@br

@openmole( s"""
    // Declare variables
    val n = Val[Int]
    val g = Val[File]
    val y =  Val[Array[Double]]

    val seed = Val[Long]

    // Task
    val task1 = ScalaTask($tq
        val rng = Random(seed)

        val dist1 = List.fill(n)(rng.nextDouble).mkString(" ")

        val g = newFile()
        g.content = dist1

        val y =  List.fill(n)(rng.nextDouble).toArray
    $tq) set (
        inputs += (n, seed),
        n := 10 ,
        outputs += (g, n, y, seed),
    )

    // Declare variable
    val res =  Val[Double]

    // Task
    val rTask = RTask($tq
        library(GeoRange)

        # Read the file created by the first scala task
        temp1=read.table("fileForR", sep="")
        x=as.vector(temp1,mode = "numeric")

        # y is the variable created in the second task

        # requiered for the function CHullArea
        liste = chull(x,y)
        hull <- cbind(x,y) [liste,]

        #require GeoRange
        area=CHullArea(hull[,1],hull[,2])

        $tq,
        install = Seq("apt update", "apt install -y libgdal-dev libproj-dev"),
        libraries = Seq("GeoRange")
    ) set(
        inputs += (n, seed),
        inputs += g mapped "fileForR",
        inputs += y.mapped,
        outputs += res mapped "area",
        outputs += (g, n, seed)
    )

    // Define hook
    val h1 = CopyFileHook(g, workDirectory / "random_points$${seed}.txt")

    // Workflow
    Replication(
        evaluation = task1 -- (rTask hook h1),
        seed = seed,
        sample = 100
    )
""")
